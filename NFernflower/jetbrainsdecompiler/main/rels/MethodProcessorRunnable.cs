// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
using System;
using Java.Lang;
using JetBrainsDecompiler.Code;
using JetBrainsDecompiler.Code.Cfg;
using JetBrainsDecompiler.Main;
using JetBrainsDecompiler.Main.Collectors;
using JetBrainsDecompiler.Main.Extern;
using JetBrainsDecompiler.Modules.Code;
using JetBrainsDecompiler.Modules.Decompiler;
using JetBrainsDecompiler.Modules.Decompiler.Deobfuscator;
using JetBrainsDecompiler.Modules.Decompiler.Stats;
using JetBrainsDecompiler.Modules.Decompiler.Vars;
using JetBrainsDecompiler.Struct;
using JetBrainsDecompiler.Struct.Gen;
using Sharpen;

namespace JetBrainsDecompiler.Main.Rels
{
	public class MethodProcessorRunnable : IRunnable
	{
		public readonly object Lock = new object();

		private readonly StructMethod method;

		private readonly MethodDescriptor methodDescriptor;

		private readonly VarProcessor varProc;

		private readonly DecompilerContext parentContext;

		private volatile RootStatement root;

		private volatile Exception error;

		private volatile bool finished = false;

		public MethodProcessorRunnable(StructMethod method, MethodDescriptor methodDescriptor
			, VarProcessor varProc, DecompilerContext parentContext)
		{
			this.method = method;
			this.methodDescriptor = methodDescriptor;
			this.varProc = varProc;
			this.parentContext = parentContext;
		}

		public virtual void Run()
		{
			error = null;
			root = null;
			try
			{
				DecompilerContext.SetCurrentContext(parentContext);
				root = CodeToJava(method, methodDescriptor, varProc);
			}
			catch (Exception t)
			{
				error = t;
			}
			finally
			{
				DecompilerContext.SetCurrentContext(null);
			}
			finished = true;
			lock (Lock)
			{
				Sharpen.Runtime.NotifyAll(Lock);
			}
		}

		/// <exception cref="System.IO.IOException"/>
		public static RootStatement CodeToJava(StructMethod mt, MethodDescriptor md, VarProcessor
			 varProc)
		{
			StructClass cl = mt.GetClassStruct();
			bool isInitializer = ICodeConstants.Clinit_Name.Equals(mt.GetName());
			// for now static initializer only
			mt.ExpandData();
			InstructionSequence seq = mt.GetInstructionSequence();
			ControlFlowGraph graph = new ControlFlowGraph(seq);
			DeadCodeHelper.RemoveDeadBlocks(graph);
			graph.InlineJsr(mt);
			// TODO: move to the start, before jsr inlining
			DeadCodeHelper.ConnectDummyExitBlock(graph);
			DeadCodeHelper.RemoveGotos(graph);
			ExceptionDeobfuscator.RemoveCircularRanges(graph);
			ExceptionDeobfuscator.RestorePopRanges(graph);
			if (DecompilerContext.GetOption(IIFernflowerPreferences.Remove_Empty_Ranges))
			{
				ExceptionDeobfuscator.RemoveEmptyRanges(graph);
			}
			if (DecompilerContext.GetOption(IIFernflowerPreferences.Ensure_Synchronized_Monitor
				))
			{
				// special case: search for 'synchronized' ranges w/o monitorexit instruction (as generated by Kotlin and Scala)
				DeadCodeHelper.ExtendSynchronizedRangeToMonitorexit(graph);
			}
			if (DecompilerContext.GetOption(IIFernflowerPreferences.No_Exceptions_Return))
			{
				// special case: single return instruction outside of a protected range
				DeadCodeHelper.IncorporateValueReturns(graph);
			}
			//		ExceptionDeobfuscator.restorePopRanges(graph);
			ExceptionDeobfuscator.InsertEmptyExceptionHandlerBlocks(graph);
			DeadCodeHelper.MergeBasicBlocks(graph);
			DecompilerContext.GetCounterContainer().SetCounter(CounterContainer.Var_Counter, 
				mt.GetLocalVariables());
			if (ExceptionDeobfuscator.HasObfuscatedExceptions(graph))
			{
				DecompilerContext.GetLogger().WriteMessage("Heavily obfuscated exception ranges found!"
					, IFernflowerLogger.Severity.Warn);
				if (!ExceptionDeobfuscator.HandleMultipleEntryExceptionRanges(graph))
				{
					DecompilerContext.GetLogger().WriteMessage("Found multiple entry exception ranges which could not be splitted"
						, IFernflowerLogger.Severity.Warn);
				}
				ExceptionDeobfuscator.InsertDummyExceptionHandlerBlocks(graph, cl.GetBytecodeVersion
					());
			}
			RootStatement root = DomHelper.ParseGraph(graph);
			FinallyProcessor fProc = new FinallyProcessor(md, varProc);
			while (fProc.IterateGraph(mt, root, graph))
			{
				root = DomHelper.ParseGraph(graph);
			}
			// remove synchronized exception handler
			// not until now because of comparison between synchronized statements in the finally cycle
			DomHelper.RemoveSynchronizedHandler(root);
			//		LabelHelper.lowContinueLabels(root, new HashSet<StatEdge>());
			SequenceHelper.CondenseSequences(root);
			ClearStructHelper.ClearStatements(root);
			ExprProcessor proc = new ExprProcessor(md, varProc);
			proc.ProcessStatement(root, cl);
			SequenceHelper.CondenseSequences(root);
			StackVarsProcessor stackProc = new StackVarsProcessor();
			do
			{
				stackProc.SimplifyStackVars(root, mt, cl);
				varProc.SetVarVersions(root);
			}
			while (new PPandMMHelper().FindPPandMM(root));
			while (true)
			{
				LabelHelper.CleanUpEdges(root);
				do
				{
					MergeHelper.EnhanceLoops(root);
				}
				while (LoopExtractHelper.ExtractLoops(root) || IfHelper.MergeAllIfs(root));
				if (DecompilerContext.GetOption(IIFernflowerPreferences.Idea_Not_Null_Annotation))
				{
					if (IdeaNotNullHelper.RemoveHardcodedChecks(root, mt))
					{
						SequenceHelper.CondenseSequences(root);
						stackProc.SimplifyStackVars(root, mt, cl);
						varProc.SetVarVersions(root);
					}
				}
				LabelHelper.IdentifyLabels(root);
				if (InlineSingleBlockHelper.InlineSingleBlocks(root))
				{
					continue;
				}
				// initializer may have at most one return point, so no transformation of method exits permitted
				if (isInitializer || !ExitHelper.CondenseExits(root))
				{
					break;
				}
			}
			// FIXME: !!
			//if(!EliminateLoopsHelper.eliminateLoops(root)) {
			//  break;
			//}
			ExitHelper.RemoveRedundantReturns(root);
			SecondaryFunctionsHelper.IdentifySecondaryFunctions(root, varProc);
			varProc.SetVarDefinitions(root);
			// must be the last invocation, because it makes the statement structure inconsistent
			// FIXME: new edge type needed
			LabelHelper.ReplaceContinueWithBreak(root);
			mt.ReleaseResources();
			return root;
		}

		/// <exception cref="System.Exception"/>
		public virtual RootStatement GetResult()
		{
			Exception t = error;
			if (t != null)
			{
				throw t;
			}
			return root;
		}

		public virtual bool IsFinished()
		{
			return finished;
		}
	}
}
